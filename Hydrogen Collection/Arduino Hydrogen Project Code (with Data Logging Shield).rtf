// Include necessary libraries
#include <LiquidCrystal_I2C.h> // For I2C LCD display
#include <SPI.h>             // Required for SD card communication
#include <SD.h>              // For SD card operations
#include "RTClib.h"          // For Real-Time Clock (RTC) module (e.g., DS1307, DS3231)

// Pin Definitions
const int PUSH_BUTTON_PIN = 2;    // Digital pin for the momentary push button
const int GREEN_LED_PIN = 3;      // Digital pin for the Green LED
const int RED_LED_PIN = 4;        // Digital pin for the Red LED
const int PROXIMITY_SENSOR_PIN = 5; // Digital pin for the IR break beam sensor (Pimoroni COM1704)
const int SOLENOID_CONTROL_PIN = 6; // Digital pin to control the NPN transistor for the solenoid

const int CURRENT_SENSOR_PIN = A0; // Analog pin for the current sensor (ACS712)
const int VOLTAGE_SENSOR_PIN = A1; // Analog pin for the voltage sensor

// SD Card Chip Select (CS) pin - typically D10 for data logging shields
const int SD_CS_PIN = 10;

// LCD configuration (adjust I2C address if needed, common ones are 0x27 or 0x3F)
LiquidCrystal_I2C lcd(0x27, 16, 2); // Set the LCD I2C address (e.g., 0x27), 16 columns and 2 rows

// RTC object
RTC_DS1307 rtc; // For DS1307 RTC module (common on older shields)
// RTC_DS3231 rtc; // Uncomment this and comment the above line if your shield has a DS3231 RTC

// --- State Variables ---
enum ProcessState {
  IDLE,
  RUNNING,
  FINISHED
};
ProcessState currentState = IDLE;

// --- Time Measurement Variables ---
unsigned long startTime = 0;
unsigned long elapsedTime = 0;

// --- Button Debounce Variables ---
long lastDebounceTime = 0;  // The last time the output pin was toggled
long debounceDelay = 50;    // The debounce time; increase if the output flickers

// --- Sensor Calibration Values (Adjust these based on your specific sensors and testing) ---
const int CURRENT_SENSOR_OFFSET_ANALOG = 512; // Analog reading when 0A current flows (adjust if needed)
const float CURRENT_SENSOR_SENSITIVITY_MV_PER_AMP = 185.0; // mV per Amp for ACS712 5A module

const float VOLTAGE_SENSOR_CALIBRATION_FACTOR = 5.0; // Adjust this based on your voltage sensor's ratio
const float ADC_RESOLUTION = 1024.0; // 10-bit ADC for Arduino Uno/Nano
const float REFERENCE_VOLTAGE = 5.0; // Arduino's analog reference voltage (VCC)

// --- Experiment Method Label ---
// Change this string to reflect the current hydrogen production method you are testing
String currentMethod = "Electrolysis Method A"; // Example: "Method A", "Method B", "Solar", etc.

// --- Data Logging File ---
File dataFile;
char fileName[13]; // Max 8.3 filename + null terminator (e.g., LOG00000.CSV)
int fileIndex = 0; // To create unique filenames

void setup() {
  // Initialize Serial Communication for debugging AND for PyPortal communication
  Serial.begin(9600);
  Serial.println("Arduino: Hydrogen Bottle Filling Project - Ready");

  // Initialize LCD
  lcd.init();      // Initialize the LCD
  lcd.backlight(); // Turn on the backlight
  lcd.print("Project Ready!");
  lcd.setCursor(0, 1);
  lcd.print("Press Button");

  // Set Pin Modes
  pinMode(PUSH_BUTTON_PIN, INPUT_PULLUP); // Use internal pull-up resistor for the button
  pinMode(GREEN_LED_PIN, OUTPUT);
  pinMode(RED_LED_PIN, OUTPUT);
  pinMode(PROXIMITY_SENSOR_PIN, INPUT_PULLUP); // Use internal pull-up for IR break beam sensor (Pimoroni COM1704)
  pinMode(SOLENOID_CONTROL_PIN, OUTPUT);

  // Initial state: All outputs off
  digitalWrite(GREEN_LED_PIN, LOW);
  digitalWrite(RED_LED_PIN, LOW);
  digitalWrite(SOLENOID_CONTROL_PIN, LOW);

  // --- Initialize SD Card ---
  Serial.print("Initializing SD card...");
  if (!SD.begin(SD_CS_PIN)) {
    Serial.println("SD card initialization failed!");
    lcd.clear();
    lcd.print("SD Init Failed!");
    while (1); // Halt if SD fails
  }
  Serial.println("SD card initialized.");
  lcd.clear();
  lcd.print("SD Ready!");

  // Find next available filename
  do {
    sprintf(fileName, "LOG%05d.CSV", fileIndex); // e.g., LOG00000.CSV, LOG00001.CSV
    fileIndex++;
  } while (SD.exists(fileName));
  Serial.print("Logging to file: ");
  Serial.println(fileName);
  lcd.setCursor(0, 1);
  lcd.print(fileName);
  delay(1000); // Show filename briefly

  // --- Initialize RTC ---
  Serial.print("Initializing RTC...");
  if (!rtc.begin()) {
    Serial.println("RTC not found!");
    lcd.clear();
    lcd.print("RTC Not Found!");
    // You might want to halt here or continue without timestamps
    // For now, we'll continue but data won't have RTC timestamps
  } else {
    Serial.println("RTC found.");
    if (rtc.lostPower()) {
      Serial.println("RTC lost power, setting time!");
      // When time needs to be set on a new device, or if power goes out
      // rtc.adjust(DateTime(F(__DATE__), F(__TIME__))); // Set to compile time
      // Or set a specific date/time:
      // rtc.adjust(DateTime(2025, 7, 11, 10, 0, 0)); // Year, Month, Day, Hour, Minute, Second
      lcd.clear();
      lcd.print("RTC Time Set!");
    }
  }
  delay(1000); // Show RTC status briefly
  lcd.clear();
  lcd.print("Project Ready!");
  lcd.setCursor(0, 1);
  lcd.print("Press Button");
}

void loop() {
  // Read button state with debounce
  int buttonState = digitalRead(PUSH_BUTTON_PIN);

  // Read IR break beam sensor state
  // For Pimoroni COM1704: HIGH means beam unbroken, LOW means beam broken (bottle detected)
  int proximityState = digitalRead(PROXIMITY_SENSOR_PIN);

  // State Machine Logic
  switch (currentState) {
    case IDLE:
      // If button is pressed and debounced, start the process
      if (buttonState == LOW && (millis() - lastDebounceTime) > debounceDelay) {
        lastDebounceTime = millis(); // Reset debounce timer
        currentState = RUNNING;
        startProcess();
      }
      break;

    case RUNNING:
      // Check if IR break beam sensor is triggered (bottle reached top)
      // For Pimoroni COM1704: LOW means beam broken (bottle detected)
      if (proximityState == LOW) {
        currentState = FINISHED;
        finishProcess();
      } else {
        // Continue measuring and updating display and logging data
        updateMeasurements();
      }
      break;

    case FINISHED:
      // Stay in FINISHED state, display final results
      // If button is pressed, reset to IDLE state
      if (buttonState == LOW && (millis() - lastDebounceTime) > debounceDelay) {
        lastDebounceTime = millis(); // Reset debounce timer
        resetProcess();
      }
      break;
  }
}

void startProcess() {
  Serial.println("Arduino: Process Started!");
  Serial.println("PROCESS_START"); // Signal to PyPortal (if connected)

  lcd.clear();
  lcd.print("Process Running...");

  digitalWrite(GREEN_LED_PIN, HIGH);     // Turn on Green LED
  digitalWrite(RED_LED_PIN, LOW);        // Ensure Red LED is off
  digitalWrite(SOLENOID_CONTROL_PIN, HIGH); // Open Solenoid Valve

  startTime = millis(); // Record start time

  // Open the log file and write header
  dataFile = SD.open(fileName, FILE_WRITE);
  if (dataFile) {
    Serial.print("Logging to "); Serial.println(fileName);
    // Write CSV header
    dataFile.println("Timestamp,Elapsed_ms,Voltage_V,Current_A,Method");
    dataFile.close();
  } else {
    Serial.println("Error opening data file for writing!");
    lcd.setCursor(0, 1);
    lcd.print("File Error!");
  }
}

void finishProcess() {
  Serial.println("Arduino: Process Finished!");
  elapsedTime = millis() - startTime; // Calculate elapsed time

  digitalWrite(GREEN_LED_PIN, LOW);      // Turn off Green LED
  digitalWrite(RED_LED_PIN, HIGH);       // Turn on Red LED
  digitalWrite(SOLENOID_CONTROL_PIN, LOW); // Close Solenoid Valve

  // Display final results on LCD
  lcd.clear();
  lcd.print("Finished! Time:");
  lcd.setCursor(0, 1);
  lcd.print(elapsedTime / 1000.0, 1); // Display time in seconds with 1 decimal place
  lcd.print("s");

  // Log final data point to SD card
  logData();

  // Send final data point and signal to PyPortal (if connected)
  float current = readCurrent();
  float voltage = readVoltage();
  Serial.print(elapsedTime / 1000.0, 1); Serial.print(",");
  Serial.print(voltage, 2); Serial.print(",");
  Serial.print(current, 2); Serial.print(",");
  Serial.println(currentMethod); // Send the final method label

  Serial.println("PROCESS_FINISHED"); // Signal to PyPortal that process is complete
}

void resetProcess() {
  Serial.println("Arduino: Process Reset!");
  currentState = IDLE;
  digitalWrite(GREEN_LED_PIN, LOW);
  digitalWrite(RED_LED_PIN, LOW);
  digitalWrite(SOLENOID_CONTROL_PIN, LOW);

  // Find next available filename for the new log
  do {
    fileIndex++;
    sprintf(fileName, "LOG%05d.CSV", fileIndex); // Increment file index for next run
  } while (SD.exists(fileName));

  lcd.clear();
  lcd.print("Project Ready!");
  lcd.setCursor(0, 1);
  lcd.print(fileName); // Show new filename
  delay(1000);
  lcd.clear();
  lcd.print("Project Ready!");
  lcd.setCursor(0, 1);
  lcd.print("Press Button");

  Serial.println("PROCESS_START"); // Signal to PyPortal for a new start (clears graph)
}

void updateMeasurements() {
  elapsedTime = millis() - startTime; // Update elapsed time continuously

  float current = readCurrent();
  float voltage = readVoltage();

  // Print to Arduino Serial Monitor for debugging and PyPortal
  Serial.print("Arduino: Time: "); Serial.print(elapsedTime / 1000.0, 1); Serial.print("s | ");
  Serial.print("Current: "); Serial.print(current, 2); Serial.print("A | ");
  Serial.print("Voltage: "); Serial.print(voltage, 2); Serial.println("V");

  // Send data to PyPortal in CSV format: Time,Voltage,Current,Method
  Serial.print(elapsedTime / 1000.0, 1); Serial.print(","); // Time in seconds
  Serial.print(voltage, 2); Serial.print(",");             // Voltage with 2 decimal places
  Serial.print(current, 2); Serial.print(",");             // Current with 2 decimal places
  Serial.println(currentMethod);                            // Method label

  // Update LCD display
  lcd.setCursor(0, 0);
  lcd.print("Time: ");
  lcd.print(elapsedTime / 1000.0, 1); // Display time in seconds with 1 decimal place
  lcd.print("s");
  lcd.print("   "); // Clear remaining characters

  lcd.setCursor(0, 1);
  lcd.print("V:");
  lcd.print(voltage, 2); // Display voltage with 2 decimal places
  lcd.print(" I:");
  lcd.print(current, 2); // Display current with 2 decimal places
  lcd.print("   "); // Clear remaining characters

  // Log data to SD card
  logData();
}

void logData() {
  dataFile = SD.open(fileName, FILE_WRITE); // Open file in append mode
  if (dataFile) {
    DateTime now = rtc.now(); // Get current time from RTC
    // Format: YYYY-MM-DD HH:MM:SS,Elapsed_ms,Voltage_V,Current_A,Method
    dataFile.print(now.year(), DEC);
    dataFile.print("/");
    dataFile.print(now.month(), DEC);
    dataFile.print("/");
    dataFile.print(now.day(), DEC);
    dataFile.print(" ");
    dataFile.print(now.hour(), DEC);
    dataFile.print(":");
    dataFile.print(now.minute(), DEC);
    dataFile.print(":");
    dataFile.print(now.second(), DEC);
    dataFile.print(",");
    dataFile.print(elapsedTime);
    dataFile.print(",");
    dataFile.print(readVoltage(), 2);
    dataFile.print(",");
    dataFile.print(readCurrent(), 2);
    dataFile.print(",");
    dataFile.println(currentMethod);
    dataFile.close();
  } else {
    Serial.println("Error opening data file for logging!");
    lcd.setCursor(0, 1);
    lcd.print("Log Error!");
  }
}

float readCurrent() {
  int analogValue = analogRead(CURRENT_SENSOR_PIN);
  float voltage_at_sensor = (analogValue / ADC_RESOLUTION) * REFERENCE_VOLTAGE;
  float current_voltage_diff = voltage_at_sensor - (REFERENCE_VOLTAGE / 2.0);
  float current = current_voltage_diff / (CURRENT_SENSOR_SENSITIVITY_MV_PER_AMP / 1000.0);
  return current;
}

float readVoltage() {
  int analogValue = analogRead(VOLTAGE_SENSOR_PIN);
  float voltage = (analogValue / ADC_RESOLUTION) * REFERENCE_VOLTAGE * VOLTAGE_SENSOR_CALIBRATION_FACTOR;
  return voltage;
}